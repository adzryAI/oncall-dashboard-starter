// src/codemods/v0-11/content-part-to-message-part.ts
import { createTransformer } from "../utils/createTransformer.js";
var typeRenamingMap = {
  // Core types
  TextContentPart: "TextMessagePart",
  ReasoningContentPart: "ReasoningMessagePart",
  SourceContentPart: "SourceMessagePart",
  ImageContentPart: "ImageMessagePart",
  FileContentPart: "FileMessagePart",
  Unstable_AudioContentPart: "Unstable_AudioMessagePart",
  ToolCallContentPart: "ToolCallMessagePart",
  // Status types
  ContentPartStatus: "MessagePartStatus",
  ToolCallContentPartStatus: "ToolCallMessagePartStatus",
  // Thread message parts
  ThreadUserContentPart: "ThreadUserMessagePart",
  ThreadAssistantContentPart: "ThreadAssistantMessagePart",
  // Runtime and state types
  ContentPartRuntime: "MessagePartRuntime",
  ContentPartState: "MessagePartState",
  // Component types
  EmptyContentPartComponent: "EmptyMessagePartComponent",
  TextContentPartComponent: "TextMessagePartComponent",
  ReasoningContentPartComponent: "ReasoningMessagePartComponent",
  SourceContentPartComponent: "SourceMessagePartComponent",
  ImageContentPartComponent: "ImageMessagePartComponent",
  FileContentPartComponent: "FileMessagePartComponent",
  Unstable_AudioContentPartComponent: "Unstable_AudioMessagePartComponent",
  ToolCallContentPartComponent: "ToolCallMessagePartComponent",
  // Props types
  EmptyContentPartProps: "EmptyMessagePartProps",
  TextContentPartProps: "TextMessagePartProps",
  ReasoningContentPartProps: "ReasoningMessagePartProps",
  SourceContentPartProps: "SourceMessagePartProps",
  ImageContentPartProps: "ImageMessagePartProps",
  FileContentPartProps: "FileMessagePartProps",
  Unstable_AudioContentPartProps: "Unstable_AudioMessagePartProps",
  ToolCallContentPartProps: "ToolCallMessagePartProps",
  // Provider types
  TextContentPartProvider: "TextMessagePartProvider",
  TextContentPartProviderProps: "TextMessagePartProviderProps",
  ContentPartRuntimeProvider: "MessagePartRuntimeProvider",
  // Context types
  ContentPartContext: "MessagePartContext",
  ContentPartContextValue: "MessagePartContextValue",
  // Hook names
  useContentPart: "useMessagePart",
  useContentPartRuntime: "useMessagePartRuntime",
  useContentPartText: "useMessagePartText",
  useContentPartReasoning: "useMessagePartReasoning",
  useContentPartSource: "useMessagePartSource",
  useContentPartFile: "useMessagePartFile",
  useContentPartImage: "useMessagePartImage",
  useTextContentPart: "useTextMessagePart",
  // Primitive names
  ContentPartPrimitive: "MessagePartPrimitive",
  ContentPartPrimitiveText: "MessagePartPrimitiveText",
  ContentPartPrimitiveImage: "MessagePartPrimitiveImage",
  ContentPartPrimitiveInProgress: "MessagePartPrimitiveInProgress"
};
var migrateContentPartToMessagePart = createTransformer(
  ({ j, root, markAsChanged }) => {
    root.find(j.ImportDeclaration).forEach((path) => {
      const source = path.value.source.value;
      if (typeof source === "string" && source.startsWith("@assistant-ui/")) {
        path.value.specifiers?.forEach((specifier) => {
          if (j.ImportSpecifier.check(specifier)) {
            const oldName = specifier.imported.name;
            if (typeRenamingMap[oldName]) {
              specifier.imported.name = typeRenamingMap[oldName];
              if (specifier.local && specifier.local.name === oldName) {
                specifier.local.name = typeRenamingMap[oldName];
              }
              markAsChanged();
            }
          }
        });
      }
    });
    root.find(j.MemberExpression).forEach((path) => {
      if (path.value.object && path.value.object.name === "MessagePrimitive" && path.value.property && path.value.property.name === "Content") {
        path.value.property.name = "Parts";
        markAsChanged();
      }
    });
    root.find(j.JSXMemberExpression).forEach((path) => {
      if (path.value.object && path.value.object.name === "MessagePrimitive" && path.value.property && path.value.property.name === "Content") {
        path.value.property.name = "Parts";
        markAsChanged();
      }
    });
    Object.entries(typeRenamingMap).forEach(([oldName, newName]) => {
      root.find(j.TSTypeReference).forEach((path) => {
        if (path.value.typeName && path.value.typeName.name === oldName) {
          path.value.typeName.name = newName;
          markAsChanged();
        }
      });
      root.find(j.Identifier).forEach((path) => {
        if (path.value.name === oldName) {
          if (j.ImportSpecifier.check(path.parent.value)) {
            return;
          }
          if (j.Property.check(path.parent.value) && path.parent.value.key === path.value) {
            return;
          }
          if (j.MemberExpression.check(path.parent.value) && path.parent.value.property === path.value) {
            return;
          }
          path.value.name = newName;
          markAsChanged();
        }
      });
      root.find(j.JSXIdentifier).forEach((path) => {
        if (path.value.name === oldName) {
          path.value.name = newName;
          markAsChanged();
        }
      });
    });
  }
);
var content_part_to_message_part_default = migrateContentPartToMessagePart;
export {
  content_part_to_message_part_default as default
};
//# sourceMappingURL=content-part-to-message-part.js.map
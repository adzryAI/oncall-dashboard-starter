// src/lib/transform.ts
import { execFileSync, spawnSync } from "child_process";
import debug from "debug";
import path from "path";
import { fileURLToPath } from "url";
import * as fs from "fs";
import { sync as globSync } from "glob";
var log = debug("codemod:transform");
var error = debug("codemod:transform:error");
var __filename = fileURLToPath(import.meta.url);
var __dirname = path.dirname(__filename);
function getRelevantFiles(cwd) {
  const pattern = "**/*.{js,jsx,ts,tsx}";
  const files = globSync(pattern, {
    cwd,
    ignore: [
      "**/node_modules/**",
      "**/dist/**",
      "**/build/**",
      "**/*.min.js",
      "**/*.bundle.js"
    ]
  });
  const relevantFiles = files.filter((file) => {
    try {
      const content = fs.readFileSync(path.join(cwd, file), "utf8");
      return content.includes("assistant-ui");
    } catch {
      return false;
    }
  });
  return relevantFiles.map((file) => path.join(cwd, file));
}
function countFilesToProcess(cwd) {
  return getRelevantFiles(cwd).length;
}
function buildCommand(codemodPath, targetFiles, options) {
  const command = [
    "npx",
    "jscodeshift",
    "-t",
    codemodPath,
    ...targetFiles,
    "--parser",
    "tsx"
  ];
  if (options.dry) {
    command.push("--dry");
  }
  if (options.print) {
    command.push("--print");
  }
  if (options.verbose) {
    command.push("--verbose");
  }
  if (options.jscodeshift) {
    command.push(options.jscodeshift);
  }
  return command;
}
function parseErrors(transform2, output) {
  const errors = [];
  const errorRegex = /ERR (.+) Transformation error/g;
  const syntaxErrorRegex = /SyntaxError: .+/g;
  let match;
  while ((match = errorRegex.exec(output)) !== null) {
    const filename = match[1];
    const syntaxErrorMatch = syntaxErrorRegex.exec(output);
    if (syntaxErrorMatch) {
      const summary = syntaxErrorMatch[0];
      errors.push({ transform: transform2, filename, summary });
    }
  }
  return errors;
}
function transform(codemod, source, transformOptions, options = { logStatus: true }) {
  if (options.logStatus) {
    log(`Applying codemod '${codemod}': ${source}`);
  }
  const codemodPath = path.resolve(__dirname, `../codemods/${codemod}.js`);
  const targetFiles = options.relevantFiles || getRelevantFiles(source);
  if (targetFiles.length === 0) {
    log(`No relevant files found for codemod '${codemod}'`);
    return [];
  }
  log(`Found ${targetFiles.length} relevant files for codemod '${codemod}'`);
  const command = buildCommand(codemodPath, targetFiles, transformOptions);
  if (options.onProgress) {
    const result = spawnSync(command[0], command.slice(1), {
      encoding: "utf8",
      stdio: ["ignore", "pipe", "pipe"]
    });
    const stdout = result.stdout || "";
    const processedFiles = (stdout.match(/Processing file/g) || []).length;
    if (options.onProgress) {
      options.onProgress(processedFiles);
    }
    const errors = parseErrors(codemod, stdout);
    if (options.logStatus && errors.length > 0) {
      errors.forEach(({ transform: transform2, filename, summary }) => {
        error(
          `Error applying codemod [codemod=${transform2}, path=${filename}, summary=${summary}]`
        );
      });
    }
    return errors;
  } else {
    const stdout = execFileSync(command[0], command.slice(1), {
      encoding: "utf8",
      stdio: "pipe"
    });
    const errors = parseErrors(codemod, stdout);
    if (options.logStatus && errors.length > 0) {
      errors.forEach(({ transform: transform2, filename, summary }) => {
        error(
          `Error applying codemod [codemod=${transform2}, path=${filename}, summary=${summary}]`
        );
      });
    }
    return errors;
  }
}
export {
  countFilesToProcess,
  getRelevantFiles,
  transform
};
//# sourceMappingURL=transform.js.map